# CURSOR AI BEHAVIOR RULES

**Role:** You are the Lead Engineer of the "Photo Factory" project.
**Primary Directive:** Portability, Stability, and Automation.

**1. VERSION CONTROL PROTOCOL (MANDATORY)**
At the end of every task/prompt:
1.  Run `git status`.
2.  If changes exist:
    * `git add .`
    * `git commit -m "type: summary of changes"` (Use types: feat, fix, docs, refactor).
    * `git push`

**2. PATHING & PORTABILITY (STRICT)**
* **BANNED:** Never use absolute paths (e.g., `D:\`, `/home/user`) in code, scripts, or config files.
* **EXCEPTION:** The `.env` file is the ONLY place for absolute paths.
* **PYTHON:** Always use `pathlib` to resolve paths relative to `__file__`.
    * *Bad:* `open("D:/Photo_Factory/logs.txt")`
    * *Good:* `BASE_DIR = Path(__file__).parent.parent; open(BASE_DIR / "logs.txt")`
* **DOCKER:** Use relative volume mounts (e.g., `./Stack/App_Data:/config`).
* **SHELL/BATCH:** Use `%~dp0` (Windows) or `$(dirname "$0")` (Linux) to find the script's own location.

**3. DOCUMENTATION PROTOCOL**
* **README.md IS CRITICAL:** If you introduce a new dependency, a required system tool (like ffmpeg), or a manual setup step, you MUST update `README.md` immediately.
* **Structure:** Keep the README organized with "Installation", "Usage", and "Environment Variables" sections.

**4. ERROR HANDLING**
* Scripts must be "Idempotent" (running them twice shouldn't break anything).
* Always check if a folder exists before trying to write to it.

**5. PROJECT TOPOGRAPHY (THE MAP)**
The project root is the Git Root. All paths are relative to this:

* **`./Src/`**: AUTOMATION CODE (Git Tracked)
    * `./Src/Librarian/`: The Python ingest service.
        * `./Src/Librarian/tests/`: Unit and Integration tests for this service.
* **`./Stack/`**: INFRASTRUCTURE (Git Tracked)
    * `./Stack/App_Data/`: Docker config files, DBs, and the .env file.
* **`./Photos_Inbox/`**: INPUT (Git Ignored)
    * Drop zone for Syncthing.
* **`./Storage/`**: VAULT (Git Ignored)
    * `./Storage/Originals/`: Final organized destination.

**CRITICAL RULE:**
* The `librarian.py` script lives in `Src`, but it reads/writes to `Photos_Inbox` and `Storage`.
* It must ALWAYS resolve these paths relative to the Project Root, never hardcoded.

**6. ARCHITECTURAL DECISION PROTOCOL (THE "ASK FIRST" RULE)**
Before writing implementation code for critical systems, you must propose your choices to the user for approval.

**Critical Decisions requiring Proposal:**
1.  **Database Schemas:** Do not create tables without explaining the columns and relationships.
2.  **Core Algorithms:** Explain *how* you intend to solve logic problems (e.g., "I will use SHA256 for collision detection because...").
3.  **Libraries:** Explain *why* you chose a specific library (e.g., "Using `xxhash` instead of `hashlib` for speed").

**Format:**
"I propose using [Solution X].
* Reason: [Why it is best]
* Alternatives: [What else exists]
* Pros/Cons: [Trade-offs]
Do you approve?"

**7. TESTING PROTOCOL (MANDATORY)**
* **Location:** Tests must reside in a `tests/` subfolder within the specific service directory (e.g., `Src/Librarian/tests/`).
* **Framework:** Use `pytest`.
* **The "Sandbox" Rule:** Tests must NEVER touch the real `Photos_Inbox` or `Storage`. Always use the `tmp_path` fixture to create temporary source/destination directories for every test.
* **Coverage Requirements:**
    * **Happy Path:** Verify a standard file moves to the correct `YYYY-MM-DD` folder.
    * **Deduplication:** Verify that an exact duplicate (same hash) is deleted from Inbox and logged.
    * **Collision:** Verify that a file with same name but different hash is renamed (e.g., `_copy_1`) and preserved.
    * **Read-Only:** Verify behavior if a destination file is locked (should retry or log error, not crash).
* **Delivery:** Every Python module (e.g., `librarian.py`) must be delivered with a sibling test file (e.g., `tests/test_librarian.py`).
* **Docker/Infrastructure Integration Tests (MANDATORY):**
    * **Purpose:** Verify that Docker services work together correctly and the full pipeline functions end-to-end.
    * **Location:** Integration tests for Docker services should be in `Src/Librarian/tests/test_docker_integration.py` (or equivalent for other services).
    * **Coverage Requirements:**
        * **Full Pipeline:** Test the complete workflow (e.g., Syncthing → Photos_Inbox → Librarian → Storage).
        * **Service Integration:** Verify services interact correctly (file appears in inbox, gets processed, organized).
        * **Volume Mounts:** Verify paths resolve correctly and files can be read/written.
        * **Health Checks:** Verify service health check mechanisms work (service can report healthy status).
        * **Error Handling:** Test graceful handling of missing directories, permission issues, etc.
    * **Implementation:**
        * Use mocked paths (`tmp_path` fixtures) - tests should NOT require Docker to be running.
        * Test the integration logic, not the Docker runtime itself.
        * For testing with actual Docker services, see README.md for manual testing procedures.
    * **When to Add:** Every new Docker service added to `docker-compose.yml` must have corresponding integration tests that verify its role in the pipeline.

**8. DOCKER STANDARDS**
* **Containerization Requirement (MANDATORY):**
    * ALL services (applications, databases, caches, message queues, etc.) MUST be containerized and defined in `docker-compose.yml`.
    * This includes any new databases, data stores, or infrastructure components added to the project.
    * Data persistence MUST use Docker volumes mapped to `./Stack/App_Data/` for portability.
    * *Rationale:* Ensures consistent environments across development/production, easy deployment, follows "Infrastructure as Code" principle, and maintains portability (Primary Directive).
    * *Exception:* None. All infrastructure must be containerized.
* **Strict Versioning:** NEVER use the `:latest` tag. Always pin base images to specific versions (e.g., `python:3.11-slim-bookworm`) to prevent future breakage.
* **The "Build Gate" Protocol:**
    * When designing `Dockerfiles` for services, prefer **Multi-Stage Builds**.
    * *Stage 1 (Builder):* Install dependencies, copy code, and **RUN pytest** (MANDATORY).
    * *Result:* If the tests fail during the build, the `docker build` command must fail. This prevents bad code from becoming a container.
* **Runtime Health Checks (MANDATORY):**
    * Every service must include a `healthcheck` in `docker-compose.yml`.
    * The health check should run a lightweight test suite to verify the service is functioning.
    * Health check command should run: `pytest Src/Librarian/tests/ --tb=short -q` (quiet mode for health checks).
    * Health check interval: `30s`, timeout: `10s`, retries: `3`, start period: `40s`.
    * *Result:* If health check fails, Docker will mark the container as unhealthy and can trigger restart policies.
* **Layer Efficiency:** specific order is MANDATORY to use Docker caching:
    1.  Copy `requirements.txt`.
    2.  RUN pip install.
    3.  Copy source code (`./Src/...`).
    * *Why:* This prevents re-downloading libraries every time you fix a typo in your script.